# EVM Bytecode Toolkit

A toolkit for analyzing, manipulating, and obfuscating Ethereum Virtual Machine (EVM) bytecode. This library provides tools for security research, development, and understanding smart contract internals.

## Structure

The codebase is organized into the following modules:

```
src/
├── constants/       # Constants like opcode sizes and names
├── utils/           # Core utilities for bytecode manipulation
├── analysis/        # Analysis tools for bytecode patterns
├── obfuscation/     # Obfuscation techniques
├── services/        # External services (blockchain interactions)
└── index.js         # Main entry point
```

## Features

- **Bytecode Decoding**: Convert raw EVM bytecode into human-readable instructions
- **Function Detection**: Identify function selectors in contract bytecode
- **Jump Analysis**: Find and analyze PUSH-JUMP patterns
- **Bytecode Manipulation**: Remove or modify instructions
- **Obfuscation**: Apply various obfuscation techniques to bytecode
- **Blockchain Integration**: Fetch deployed bytecode from Ethereum mainnet

For an in-depth explanation of the bytecode obfuscation techniques used in this toolkit, see our [research documentation](https://github.com/0xsidd/evm-bytecode-obfuscation/blob/main/research.md).

## Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/evm-bytecode-toolkit.git
cd evm-bytecode-toolkit

# Install dependencies
npm install

```

## Command Line Interface

The toolkit includes a user-friendly command-line interface for obfuscating bytecode:

```bash
# Interactive mode with guided prompts
npm run cli -- --interactive

# Using command line arguments
npm run cli -- --file ./path/to/Contract.json --seed "myseed" --output ./results.json

# Or if installed globally
evm-obfuscator --file ./path/to/Contract.json
```

### CLI Options

| Option | Description |
|--------|-------------|
| `-i, --interactive` | Run in interactive mode with prompts |
| `-f, --file <path>` | Path to compiled Solidity JSON file with bytecode |
| `-a, --address <address>` | Ethereum contract address to fetch bytecode from |
| `-l, --local` | Specify if bytecode is from a locally compiled contract (default: true) |
| `-s, --seed <seed>` | Seed string for deterministic obfuscation |
| `-o, --output <path>` | Path to save obfuscated bytecode results |
| `-h, --help` | Display help information |
| `-v, --version` | Display version information |

## API Usage

```javascript
// Import necessary functions
const { 
  decodeBytecode,
  obfuscateBytecode,
  findFunctions
} = require('./src/index'); // Adjust path as needed

// Example bytecode (replace with actual bytecode)
const bytecode = "0x608060405234..."; 
const seed = "YOUR_SEED_HERE";

// Decode bytecode into instructions
const decodedInstructions = decodeBytecode(bytecode);
console.log("Decoded:", decodedInstructions);

// Find function selectors (optional)
const detectedFunctions = findFunctions(bytecode, 10); // Find top 10 functions
console.log("Functions:", detectedFunctions);

// Obfuscate bytecode with a seed
// The complexity level (e.g., 1-6) might be derived from the seed or set explicitly
const obfuscationResult = obfuscateBytecode(seed, bytecode);
console.log("Obfuscated Bytecode:", obfuscationResult.obfuscatedBytecode);
console.log("Analysis:", obfuscationResult.analysis); // Assuming result object structure

```

See `example.js` for more detailed usage examples.

## Testing with Obfuscated Bytecode

You can test your smart contracts deployed with obfuscated runtime bytecode using standard Ethereum testing frameworks like Hardhat or Foundry. The core idea is to deploy the contract instance using the original initialization code (constructor logic and arguments) combined with the obfuscated runtime bytecode generated by this toolkit.

Here's a conceptual example using Hardhat and ethers.js, similar to the approach in `contract/test/ERC20.test.js`:

```javascript
const { ethers } = require("hardhat");
const { expect } = require("chai");

// Assume you have these from your build process and the obfuscation tool
const { initCode, obfuscatedRuntimeBytecode, originalRuntimeBytecode } = require('../path/to/your/Bytecodes'); 
const ContractArtifact = require("../path/to/your/Contract.json"); // Standard Hardhat artifact

describe("Contract Testing with Obfuscation", function () {
  let deployedContract;
  let owner;

  beforeEach(async function () {
    // Get signers
    [owner] = await ethers.getSigners();

    // 1. Combine init code with OBFUSCATED runtime bytecode
    const fullObfuscatedBytecode = initCode + obfuscatedRuntimeBytecode; 
    // To test original: const fullOriginalBytecode = initCode + originalRuntimeBytecode;

    // 2. Calculate the deployment address if needed (optional, useful for predictability)
    // const nonce = await owner.getNonce();
    // const deployedAddress = ethers.getCreateAddress({ from: owner.address, nonce });

    // 3. Send the deployment transaction with the combined obfuscated bytecode
    const tx = await owner.sendTransaction({ data: fullObfuscatedBytecode });
    const receipt = await tx.wait();

    if (!receipt || !receipt.contractAddress) {
      throw new Error("Contract deployment failed or address not found in receipt.");
    }
    
    // 4. Attach the contract ABI to the deployed address
    // We use the *original* ABI because the function signatures are unchanged
    const ContractFactory = await ethers.getContractFactory(ContractArtifact.abi, owner); // Use ABI only
    deployedContract = ContractFactory.attach(receipt.contractAddress);

    // Alternative using ContractFactory directly (might be simpler if init args are complex)
    // const MyContractFactory = await ethers.getContractFactory(ContractArtifact.abi, fullObfuscatedBytecode, owner);
    // deployedContract = await MyContractFactory.deploy(/* constructor args if any */);
    // await deployedContract.deployed(); 
  });

  it("Should function correctly after obfuscation", async function () {
    // Your standard contract tests go here
    // Example: Check owner, call a view function, execute a transaction
    // These tests should pass if the obfuscation was successful and didn't break logic.
    
    // expect(await deployedContract.someViewFunction()).to.equal(expectedValue);
    // await expect(deployedContract.someTransaction(args))
    //   .to.emit(deployedContract, "SomeEvent"); 
  });
});
```

**Key Points:**

1.  **Initialization Code (`initCode`)**: Use the standard initialization bytecode generated by your Solidity compiler (e.g., `solc` or Hardhat). This includes the constructor code and encoded arguments.
2.  **Obfuscated Runtime Bytecode**: Use the output from the `obfuscateBytecode` function of this toolkit.
3.  **Concatenation**: Prepend the `initCode` to the `obfuscatedRuntimeBytecode`. This forms the complete bytecode payload needed for deployment.
4.  **Deployment**: Use your testing framework's deployment methods (like `owner.sendTransaction` or `ContractFactory.deploy` with custom bytecode) to deploy using the combined bytecode.
5.  **ABI**: Interact with the deployed contract using the *original* contract ABI. The obfuscation techniques described primarily modify control flow and add dead code, but they do not change the function selectors or the external interface (ABI) of the contract.
6.  **Testing**: Run your existing test suite against the contract deployed with the obfuscated code. If the tests pass, it indicates that the obfuscation likely preserved the original contract's functionality.

## ERC20 Obfuscation Example

The repository includes a complete working example of obfuscating and testing an ERC20 token contract:

```
contract/
├── contracts/         # Smart contract source files
│   └── ERC20.sol      # Sample ERC20 token implementation
├── test/              # Test files
│   └── ERC20.test.js  # Tests for the obfuscated ERC20 token
└── constants/         # Bytecode files
    └── Bytecodes.js   # Contains original and obfuscated bytecodes
```

The example demonstrates:

1. **Obfuscation Preservation**: The ERC20 token's functionality is fully preserved after bytecode obfuscation, with all tests passing against the obfuscated deployment.

2. **Deployment Process**: The test implementation combines initCode with obfuscated runtime bytecode:
   ```javascript
   // From contract/test/ERC20.test.js
   const { initCode, obfuscatedRuntimeBytecode } = require("../constants/Bytecodes");
   const obfuscatedBytecode = initCode + obfuscatedRuntimeBytecode;
   
   // Deploy with obfuscated bytecode
   const tx = await owner.sendTransaction({ data: obfuscatedBytecode });
   ```

3. **Comprehensive Testing**: The tests verify all ERC20 functionality works with the obfuscated bytecode:
   - Basic token properties (name, symbol, decimals)
   - Owner management
   - Minting tokens
   - Balance queries
   - Token transfers
   - Approvals and allowances
   - Transfer-from operations

This example provides a practical reference implementation for applying obfuscation to your own smart contracts while ensuring they remain functionally equivalent.

## License

MIT 